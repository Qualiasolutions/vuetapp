import 'package:flutter/foundation.dart'; // For ChangeNotifier and ValueNotifier if used elsewhere
import 'package:vuet_app/src/features/tasks/domain/entities/task_entity.dart';
// import 'package:vuet_app/src/features/tasks/domain/usecases/get_tasks_usecase.dart'; // Will use repository directly for now
// import 'package:vuet_app/src/features/tasks/domain/usecases/add_task_usecase.dart';
// import 'package:vuet_app/src/features/tasks/domain/usecases/update_task_usecase.dart';
// import 'package:vuet_app/src/features/tasks/domain/usecases/delete_task_usecase.dart';
import 'package:vuet_app/src/features/tasks/domain/repositories_abstract/task_repository.dart';
import 'package:vuet_app/src/features/tasks/data/repositories_impl/task_repository_impl.dart'; // Default implementation

enum TaskListState { initial, loading, loaded, error }

class TaskListProvider extends ChangeNotifier {
  // final GetTasksUsecase _getTasksUsecase;
  // Consider injecting individual use cases if logic becomes complex,
  // or directly use the repository for simpler CRUD.
  final TaskRepository _taskRepository;

  TaskListProvider({TaskRepository? taskRepository})
      : _taskRepository = taskRepository ?? TaskRepositoryImpl();
        // _getTasksUsecase = GetTasksUsecase(taskRepository ?? TaskRepositoryImpl()); // If still using GetTasksUsecase

  TaskListState _state = TaskListState.initial;
  TaskListState get state => _state;

  List<TaskEntity> _tasks = [];
  List<TaskEntity> get tasks => _tasks;

  String _errorMessage = '';
  String get errorMessage => _errorMessage;

  Future<void> fetchTasks() async {
    _state = TaskListState.loading;
    notifyListeners();

    try {
      // _tasks = await _getTasksUsecase.call(); // If using GetTasksUsecase
      _tasks = await _taskRepository.getTasks();
      _state = TaskListState.loaded;
    } catch (e) {
      _errorMessage = e.toString();
      _state = TaskListState.error;
      debugPrint('Error fetching tasks in provider: $e');
    }
    notifyListeners();
  }

  Future<void> createTask({
    required String title,
    String? description,
    DateTime? dueDate,
    String? priority,
    String? status,
    // Add other necessary fields from TaskEntity, except id and timestamps
  }) async {
    // Consider a loading state for this specific action if it's long
    try {
      // Constructing a TaskEntity. ID will be handled by backend/repository.
      // Timestamps like createdAt also handled by backend/repository.
      // isCompleted defaults to false in TaskEntity.
      final newTaskEntity = TaskEntity(
        id: '', // Placeholder, will be ignored or generated by backend
        title: title,
        description: description,
        dueDate: dueDate,
        priority: priority,
        status: status ?? 'pending', // Default status
      );
      final createdTask = await _taskRepository.addTask(newTaskEntity);
      _tasks.insert(0, createdTask); // Add to the beginning of the list
      _state = TaskListState.loaded; // Ensure state is loaded
    } catch (e) {
      _errorMessage = 'Failed to create task: ${e.toString()}';
      _state = TaskListState.error; // Or handle error more gracefully without changing main list state
      debugPrint(_errorMessage);
    }
    notifyListeners();
  }

  Future<void> toggleTaskCompletion(String taskId, bool isCompleted) async {
    try {
      final updatedTask = await _taskRepository.toggleTaskCompletion(taskId, isCompleted);
      final index = _tasks.indexWhere((task) => task.id == taskId);
      if (index != -1) {
        _tasks[index] = updatedTask;
      }
    } catch (e) {
      _errorMessage = 'Failed to update task completion: ${e.toString()}';
      // Optionally set _state to error or handle more gracefully
      debugPrint(_errorMessage);
    }
    notifyListeners();
  }

  Future<void> deleteTask(String taskId) async {
    try {
      await _taskRepository.deleteTask(taskId);
      _tasks.removeWhere((task) => task.id == taskId);
    } catch (e) {
      _errorMessage = 'Failed to delete task: ${e.toString()}';
      // Optionally set _state to error or handle more gracefully
      debugPrint(_errorMessage);
    }
    notifyListeners();
  }

  // Optional: Method to get a single task if TaskDetailScreen needs it from provider
  // This might be better handled by a dedicated provider or direct repository call in detail screen
  Future<TaskEntity?> getTaskById(String taskId) async {
    try {
      return await _taskRepository.getTaskById(taskId);
    } catch (e) {
      debugPrint('Error fetching task by ID in provider: $e');
      return null;
    }
  }
}

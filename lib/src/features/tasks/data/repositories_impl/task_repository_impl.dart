import 'package:flutter/foundation.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:vuet_app/src/features/tasks/data/models_supabase/task_supabase_model.dart';
import 'package:vuet_app/src/features/tasks/domain/entities/task_entity.dart';
import 'package:vuet_app/src/features/tasks/domain/repositories_abstract/task_repository.dart';
import 'package:vuet_app/config/supabase_config.dart'; // To access Supabase client

class TaskRepositoryImpl implements TaskRepository {
  final SupabaseClient _supabaseClient;

  TaskRepositoryImpl({SupabaseClient? supabaseClient})
      : _supabaseClient = supabaseClient ?? SupabaseConfig.client;

  // --- Mapper Functions ---
  // These could be moved to separate mapper classes or extensions for better organization

  TaskEntity _mapSupabaseModelToEntity(TaskSupabaseModel model) {
    return TaskEntity(
      id: model.id,
      title: model.title,
      description: model.description,
      dueDate: model.dueDate,
      priority: model.priority,
      status: model.status,
      isRecurring: model.isRecurring,
      categoryId: model.categoryId,
      createdBy: model.createdBy,
      assignedTo: model.assignedTo,
      createdAt: model.createdAt,
      completedAt: model.completedAt,
      isCompleted: model.isCompleted, 
      // Note: recurrencePattern and parentTaskId are not in TaskEntity for simplicity yet
    );
  }

  TaskSupabaseModel _mapEntityToSupabaseModel(TaskEntity entity, {String? existingId}) {
    // For inserts, ID might be generated by DB. For updates, ID is from existing entity.
    // The TaskSupabaseModel's toMap/toInsertMap/toUpdateMap handles ID presence.
    return TaskSupabaseModel(
      id: existingId ?? entity.id, // Use existingId if provided (e.g. for updates where entity.id might be different)
      title: entity.title,
      description: entity.description,
      dueDate: entity.dueDate,
      priority: entity.priority,
      status: entity.status,
      isRecurring: entity.isRecurring,
      categoryId: entity.categoryId,
      createdBy: entity.createdBy, // This should ideally be set by RLS/triggers or based on auth user
      assignedTo: entity.assignedTo,
      createdAt: entity.createdAt, // Usually handled by DB
      completedAt: entity.completedAt,
      isCompleted: entity.isCompleted,
      // recurrencePattern and parentTaskId would be mapped if present in TaskEntity
    );
  }

  @override
  Future<List<TaskEntity>> getTasks() async {
    try {
      // Adjust the query as needed, e.g., order by, filter by user
      // For "Vuet1" schema, tasks have 'created_by' and 'assigned_to'
      // We should probably fetch tasks where current user is 'created_by' or 'assigned_to'
      // or part of a shared group/family. RLS should handle most of this.
      final response = await _supabaseClient
          .from('tasks')
          .select()
          .order('created_at', ascending: false); // Example order

      final tasks = (response as List)
          .map((data) => TaskSupabaseModel.fromMap(data as Map<String, dynamic>))
          .map(_mapSupabaseModelToEntity)
          .toList();
      return tasks;
    } catch (e) {
      // Log error, throw custom domain error
      debugPrint('Error fetching tasks: $e');
      rethrow;
    }
  }

  @override
  Future<TaskEntity?> getTaskById(String id) async {
    try {
      final response = await _supabaseClient
          .from('tasks')
          .select()
          .eq('id', id)
          .maybeSingle();

      if (response == null) {
        return null;
      }
      final taskModel = TaskSupabaseModel.fromMap(response);
      return _mapSupabaseModelToEntity(taskModel);
    } catch (e) {
      debugPrint('Error fetching task by ID $id: $e');
      rethrow;
    }
  }

  @override
  Future<TaskEntity> addTask(TaskEntity task) async {
    try {
      // 'created_by' should ideally be the current authenticated user's ID.
      // Supabase RLS policies might enforce this, or it can be set here.
      // For now, assuming TaskEntity might have it or it's set by DB default/trigger if 'created_by' is not in toInsertMap.
      // The 'Vuet1' tasks table has 'created_by' which is FK to profiles.id (auth.users.id)
      
      final taskToInsert = _mapEntityToSupabaseModel(task);
      final insertData = taskToInsert.toInsertMap();
      
      // Ensure created_by is set if not handled by DB default and is required
      // This depends on how 'created_by' is handled in TaskSupabaseModel and TaskEntity
      // For "Vuet1" schema, 'created_by' is nullable but practically should be current user.
      // Let's assume it's passed in via TaskEntity or set by RLS.
      // If not, it would be: insertData['created_by'] = _supabaseClient.auth.currentUser?.id;

      final response = await _supabaseClient
          .from('tasks')
          .insert(insertData)
          .select()
          .single();
      
      final createdTaskModel = TaskSupabaseModel.fromMap(response);
      return _mapSupabaseModelToEntity(createdTaskModel);
    } catch (e) {
      debugPrint('Error adding task: $e');
      rethrow;
    }
  }

  @override
  Future<TaskEntity> updateTask(TaskEntity task) async {
    try {
      final taskToUpdate = _mapEntityToSupabaseModel(task, existingId: task.id);
      final updateData = taskToUpdate.toUpdateMap();

      final response = await _supabaseClient
          .from('tasks')
          .update(updateData)
          .eq('id', task.id)
          .select()
          .single();

      final updatedTaskModel = TaskSupabaseModel.fromMap(response);
      return _mapSupabaseModelToEntity(updatedTaskModel);
    } catch (e) {
      debugPrint('Error updating task ${task.id}: $e');
      rethrow;
    }
  }

  @override
  Future<void> deleteTask(String id) async {
    try {
      await _supabaseClient
          .from('tasks')
          .delete()
          .eq('id', id);
    } catch (e) {
      debugPrint('Error deleting task $id: $e');
      rethrow;
    }
  }

  @override
  Future<TaskEntity> toggleTaskCompletion(String taskId, bool isCompleted) async {
    try {
      final updatePayload = {
        'is_completed': isCompleted,
        'updated_at': DateTime.now().toIso8601String(),
        'completed_at': isCompleted ? DateTime.now().toIso8601String() : null,
      };

      final response = await _supabaseClient
          .from('tasks')
          .update(updatePayload)
          .eq('id', taskId)
          .select()
          .single();

      final updatedTaskModel = TaskSupabaseModel.fromMap(response);
      return _mapSupabaseModelToEntity(updatedTaskModel);
    } catch (e) {
      debugPrint('Error toggling task completion for $taskId: $e');
      rethrow;
    }
  }
}
